1.
а) Закончить Accumulator, работающий с интерфейсом Operation, который имеет следующие реализации:
Plus, Minus, Multiply, DIvide, Mod (остаток от деления), Power (возведение в степень), SquareRoot (квадратный корень).
б) Сделать аккумулятор, у которого в качестве значения массив, и такй же длины массив типа Operation[].
Каждой ячейке элемента массива значений соответствует операция из массива операций.
При вызове метода calculate() для каждой ячейки применяется соответствующая ей операция.
Например такие начальные значения в массивах (в вашем случае они должны задаваться конструктором):
int[] values = {0, 0};
Operation[] operations = {new Plus(), new Minus()};

после вызова метода calculate(1) в values должны оказаться такие значения:
|1|-1|
При следующем вызове, например, calculate(5):
|6|-6|

Конструктор будет принимать два массива: int[] и Operation[].

2. Сделать реализацию нашего интерфейса List, но только на основании массива - ArrayList.
Этот класс должен реализовывать следующие методы: add(), get(), remove() и iterator() из интерфейса List.
Если при выполнении add() в массиве нет свободных элементов, то создать новый - вдвое больше,
скопировать в него все значения из старого и + 1, который сейчас добавляется.
Удаление должно сдвинуть все элементы влево, если это требуется.
Например, если список с такими элементами:
|0|1|2|3|4|5|
Удаляем элемент по индексу 2:
|0|1|_|3|4|5|
Перемещаем все элементы влево:
|0|1|3|4|5|_|
Теперь при итерации по ним после 1 будет идти сразу 3, как в связном списке.
Если задание сделано правильно, то поведение двух списков для пользователя не будет различаться. Т.е. он может сделать:
List list1 = new LinkedList();
List list2 = new ArrayList();

И если будет выполнять одинаковые операции над обоими списками, то и результат будет таким же.